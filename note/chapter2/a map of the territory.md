
- [2 解释器领地的地图](#2-解释器领地的地图)
  - [2.1 语言的部分](#21-语言的部分)
    - [__扫描(Scanning)__](#扫描scanning)
    - [__解析(Parsing)__](#解析parsing)
    - [静态分析(Static Analysis)](#静态分析static-analysis)
    - [__中间表示(Intermediate Representation)__](#中间表示intermediate-representation)
    - [__优化(Optimization)__](#优化optimization)
    - [__代码生成(Code Generation)__](#代码生成code-generation)
    - [__虚拟机(Virtual Machine)__](#虚拟机virtual-machine)
    - [__运行时(Runtime)__](#运行时runtime)
  - [2.2 捷径和备用路线](#22-捷径和备用路线)
    - [__单趟编译器(Single-pass Interpreter)__](#单趟编译器single-pass-interpreter)
    - [__树遍历解释器(Tree-Walk Interpreter)__](#树遍历解释器tree-walk-interpreter)
    - [__转译器(Transpilers)__](#转译器transpilers)
    - [__即时编译(Just-in-time compilation)__](#即时编译just-in-time-compilation)
  - [2.3 编译器和解释器](#23-编译器和解释器)

## 2 解释器领地的地图

无论“栈”，“字节码”和“递归下降”都是一个解释器可能使用的具体实现，他不是编程语言(language)，而是编程语言的实现。从用户的角度来看，只要语言的实现诚实的符合语言的规范，那么所有实现都是细节。
作者不加区分的使用language和language implementation，除非区分很重要。
### 2.1 语言的部分
无论是计算机的黑暗时代，还是现代，编程语言实现总是有着类似的路径：

1. 从源代码开始，经过scanning操作，生成了tokens。然后对tokens执行parsing(中间有Tree-walk interp)，产出了语法树(syntax tree)，然后通过分析(analysis)，到达了顶峰。这其中每一步对程序的分析，并将代码转换为某种更高级别的表现形式，让程序的语义--这也是程序的作者希望计算机执行的事情--更加清晰。

2. 然后，我们到达了顶峰，获取到了对用户程序的鸟瞰视角，可以知道了代码的意图。接着，我们向下，通过不断地优化(optimizing)产生中间表示(intermediate representations)，将最高级的表示向下依次转换为低级的形式（通过代码生成，转换为字节码 bytecode或者机器码 machine code），这些形式越来越接近我们所知的CPU实际执行的形式。

3. 语法树以及分析后生成的优化的中间表示，也可以通过transpiling为高级语言。

#### __扫描(Scanning)__

第一步是 __扫描(scanning)__，也叫做 __分词(lexing)__，或者 __是词法分析(lexical analysis)__。

scanner(或者叫lexer)的输入是线性字符流，然后通过把它们分组，产出token。token可以是单个字符的，也可以是多个字符的。源文件中有些字符对于解释器是无意义的，比如空白字符，或者注释(注：注释对于人来说，很有意义)。通常会在scanner这一步丢弃掉。

#### __解析(Parsing)__
第二步是 __扫描(parsing)__。在这里，我们的 __语法(syntax)__ 得到一个 __句法(grammar)__。grammar的能力是从很小的部分组成更大的表达式和语句。

__解析器(parser)__ 的输入是token的平坦序列，然后构建一个树结构，这个树结构反映了grammar的嵌套特性。这个树有多个不同的名字，__解析树(parse tree)__ 或者 __抽象语法树(abstract syntax tree)__，叫什么名字依赖于它们有多接近源语言裸的语法结构。实践中，一般称它们 __语法树(syntax trees)__，__AST__。解析器还负责报告 __语法错误(syntax error)__。

#### 静态分析(Static Analysis)
前两步在所有实现都是类似的，从这一步开始，每个语言独立的特性开始起作用。此时我们知道了代码的语法结构，比如表达式是如何嵌套的，但是再多的就不知道了，例如，`a + b`这个表达式，我们直到的是`a`和`b`相加，但是，我们不知道这两个名字引用的是什么。它们是局部变量还是全局变量，它们有没有被定义。

大多数语言会做的一开始的分析叫做 __绑定(binding)__ 或者 __决议(resolution)__。对于每个 __标识符(identifier)__，我们找到这个名字定义的地方并将二者连起来。这里 __作用域(scope)__ 发挥的地方。作用域是源代码中的一个区域，在这里某个名字用来指向某个声明。

如果语言是静态类型的，那么此时进行类型检查，当我们知道某个名字声明的地方，我们就可以进行类型检查。如果类型检查有问题，我们就会报告 __类型错误__。

从分析中获取到所有这些对我们可见的语义见解都需要存储在某个地方。我们有几个地方存储：
+ 会作为 __属性(attributes)__ 直接存储在语法树自身上——节点中在解析过程中没有初始化而是稍后填充的额外属性。
+ 其他时候，我们可以将数据存在一旁的查找表中。典型地，这个表的key是标识符——变量和声明的名字。此时，我们称这个表为 __符号表(symbol table)__，每个key关联的值告诉我们那个标识符指向什么。
+ 最有力的簿记工具是转换这个树为全新的数据结构，这个数据结构可以更加直接的表示代码的语义，称之为 __[中间表示](#中间表示intermediate-representation)__。

#### __中间表示(Intermediate Representation)__
我们可以将编译器看作是一个流水线，每一阶段的工作就是以某种方式组织代表用户代码的数据结构，从而让下一阶段容易实现。编译器的前端是特定于编写程序所用的源语言(The front end of pipeline is specific to the source language the program is written in)。后端和程序运行的最终架构有关。

在这之间，代码可以以某种 __中间表示(intermediate representation IR)__ 储存，IR既不和源形式也不目标形式有紧密的绑定(IR isn't tightly tied to either the source or destination froms(hence "intermediate"))。IR扮演的就是那两个语言的接口。

这允许你在很少的代价就可以支持多个源语言和目标平台。如果没有IR，每一个语言到每一个平台都要有一套实现。一个共享的中间表示可以大幅减少这种情况。针对每个源语言编写一个前端产生这个IR，对于每一个目标架构只需要一个后端。这样你就可以混和各种语言了。还有另一个大的原因让我们想要转换代码为一种让语义更加明显的形式就是为了 __[优化](#优化optimization)__。

#### __优化(Optimization)__
一旦我们理解了用户程序的意义，我们就可以自由的将它替换为有着相同语义的另一个程序，后者有着更高效的实现——我们可以 __优化(optimization)__ 它。

一个简单的例子 __常量折叠(constant folding)__：如果某个表达式总是评估(evaluates)出完全一样的值，我们可以在编译时就执行evaluate，并用它的结果替换表达式代码。很多成功的语言只做了少量的编译期优化，只产生相对为优化代码，而专注于运行时的性能影响。
>一些编译期优化的关键字：常量传播(constant propagation)，公共子表达式消除(common subexpression elimination)，循环不变代码移动(loop invariant code motion)，全局值编号(global value numbering)，强度减少(strength reduction)，聚合标量替换(scalar replacement of aggregates)，死代码消除(dead code elimination)和循环展开(loop unrolling)

#### __代码生成(Code Generation)__
做完了所有可以使用的优化，最后一步是将它转换为机器可以实际运行的形式。换句话说，__生成代码(generating code 或者是 code gen)__ 中的“代码”通常指的是一个CPU运行的某种初级的类似汇编的指令而不是某种人类可读的“源代码”。

然后，我们到达了 __后端(back end)__，从此开始，我们代码的表示越来越初级，越来越接近我们简单智能的机器可以理解的形式。这里也是做出是生成真正CPU的指令还是虚拟的指令。

如果是真实的机器码，就可以在芯片上直接运行。原生码非常快，但是生成它很费功夫。现在的架构有大量的指令，复杂的流水线，以及大量的历史包袱。而且这样也意味着你的编译器仅仅绑定特定的架构。

所以，还有一个选择是产生虚拟的机器码(virtual machine code)。不是产生某些真实的芯片指令，它们针对假设的，理想化的机器产生代码。由于现在每个指令通常是单个字节的长度，我们称之为 __字节码(bytecode)__。这些指令被设计的更接近与语言的语义，而不会和任意一个计算机架构特性有深度绑定。你可以认为它好像是这个语言低级操作的一个密实的，二进制编码。

#### __虚拟机(Virtual Machine)__
如果是字节码，还需要将字节码进行一次转换。有两个选择：
1. 针对每个目标架构写一个小的迷你编译器，转换字节码为目标机器的本地代码。这其实就是用字节码作为中间表示，虽然你依旧需要对每个芯片编写代码，但是最后一步就很简单了，而且还可以跨你支持的所有机器重用编译器流水线剩余的部分。
2. 或者你可以编写一个 __虚拟机(VM)__，这个程序在运行时模拟了可以支持你架构的假设芯片。在VM中运行字节码比将程序AOT(ahead of time)为原生码要慢，因为每次指令被执行时，都需要在运行时模拟。然而，这样就很简单并且可移植。比如，用C写了你的VM，那么所有有C编译器的平台都可以运行你的语言。

#### __运行时(Runtime)__
无论是翻译成原始码还是在VM中执行，除了最基本的低层语言之外，在这个程序运行的时候，我们需要我们语言提供的某些服务。例如，语言如果支持自动内存管理，那么我们就需要提供一个垃圾收集器。如果语言支持“instance of”测试，那么我们需要某种表示方式，在执行期间，跟踪每个对象的类型。所有这些都发生在运行时，因此也叫做 __运行时(runtime)__。如果是一个完全编译的语言，那么实现了运行时的代码就会直接插入到可执行软件中。例如`Golang`，每个编译后的应用都有一份自己的Go运行时嵌入在它内部。如果语言是运行在一个解释器或者VM，那么运行时就在这里面。Java，Python和JavaScript就是这样工作的。

### 2.2 捷径和备用路线

#### __单趟编译器(Single-pass Interpreter)__
某些简单的编译器将解析，分析和代码生成套在一起从而它们在parser中直接输出代码，而不会分配任何语法树和其他IRs。这些 __单趟编译器(single-pass compilers)__ 限制了语言的设计。没有中间数据结构存放程序的全局信息，而且无法回看任何前面已经解析的代码部分。这意味着只要你看到了某些表达式，你需要知道足够的信息来正确的编译它。Pascal和C就是这样设计的，因为当时这些语言出现的时候，内存无法容纳所有源文件。这也是为什么C不允许调用在声明函数前调用它，除非有一个显式的前向声明告诉编译器它需要知道的信息，从而可以生成代码调用后面的函数。

#### __树遍历解释器(Tree-Walk Interpreter)__
某些编程语言在代码被解析为AST后(可能会应用一些静态分析)就立即开始执行了。为了运行这个程序，解释器一次遍历语法树一个分支和叶子，随着它的前进evaluate每个节点。由于这个方式可能会很慢，因此在通用目的语言中没有广泛的使用。

#### __转译器(Transpilers)__
如果存在一个通用IR作为目标，那么我们的前端可以以它为目标。还可以以其他 _源语言_ 作为中间表示。我们可以针对我们的语言编写一个前端。然后，在后端，不是将语义降低为某个基本目标语言，而是产生和你的语言一样高级的其他语言的合法源码字符串。然后利用那个语言已经存在的编译套件执行转译后的代码。这叫做 __源码转源码编译器(source-to-source compiler)__ 或者是 __转换编译器(transcompiler)__，也叫做 __转译器(transpiler)__。

转译器的前端——scanner和parser——和其他编译器类似。然后，如果源语言只是目标语言的套了一层简单的语法皮肤，那么就会跳过整个分析阶段直接输出目标语言的同义语法。如果两个语言有更多的语义上的不同，就可能会有更多的典型的完全的编译器阶段，包括分析和甚至是优化。接着是代码生成，这里不再是生成像是机器码那样的二进制语言，而是生成目标语言的语法上正确源(目标)代码。

#### __即时编译(Just-in-time compilation)__
像Java，C#和JavaScript这些语言的运行时，HotSpot Java Virtual Machine(JVM)，Microsoft's Common Language Runtime(CLR)和V8那样，在终端用户的机器上，当程序被加载的时候(JS的话就是源代码，Java或者C#的话就是针对JVM和CLR的平台无关字节码)，就会编译成用户计算机支持的架构。这叫做 __即时编译(Just-in-time compilation)__，也叫做JIT。

### 2.3 编译器和解释器
* __编译(compiling)__ 是一个实现技术，涉及到转换源码到另一个其他形式(通常是更低级的)。生成字节码或者机器码，转译成另一个高级语言都是编译。
* 当我们说一个语言实现“是一个 __编译器(compiler)__”，我们的意思是它将源码转换为另一个其他形式但是不执行。用户要自己运行结果输出。
* 反之，当我们说一个实现“是一个 __解释器(interpreter)__”，我们的意思是它输入一个源代码并立即执行它。它“从源代码”运行程序。

GCC和Clang就是C语言的编译器。

旧版的Matz的Ruby候选实现是从源码执行Ruby。这个实现解析了ruby程序后直接通过遍历语法树执行它。没有任何翻译发生，无论是内部的还是用户可见的形式(即不会有IR，也不会有字节码)。

而CPython，当你使用CPython执行Python程序，代码被解析然后转换为内部的字节码形式，然后再VM内执行。用户虽然看到的是从源码执行，但是内部却发生了编译行为。

因此CPython是一个解释器，但是它有一个编译器。实际上，大多数脚本都是这个工作方式。

是纯Compiler的: javac,GCC,TypeScript,CoffeeScript,Rust,clang
是纯Interpreter的:MRI(Ruby),jlox,PHP3
包含Compiler和Interpreter的:C#,Haskell,CPython,YARV(Ruby),Lua,clox,Go,Guile(Scheme),Scala,V8(JS),PHP4
(注：Java和C#不是类似的么，虽然可以理解Javac会编译java代码为字节码，但是C#也是这样的吧，为什么给C#归到中间呢?)

- [第一部分](#第一部分)
  - [第一章：介绍](#第一章介绍)
    - [为什么要学习实现编程语言(实现编程语言的解释器/编译器)](#为什么要学习实现编程语言实现编程语言的解释器编译器)
    - [本书怎么样](#本书怎么样)
    - [第一个解释器](#第一个解释器)
    - [第二个解释器](#第二个解释器)
# 第一部分
这可能是为大冒险的开始。编程语言包含了巨大的空间以供探索和玩耍。这一部分的章节向你介绍了编程语言使用的基本概念以及这些概念是如何组织的。我们也将熟悉Lox，这个语言是本书接下来将要实现的(两次)。
## 第一章：介绍
本书是关于实现编程语言解释器的。也是一本关于如何设计一个值得实现的语言的书。本书，我们将一步一步实现针对一个语言的两个完整解释器。本书的理论知识比其他的书要少。

当设计一门语言时，能够精确且形式化的推导语法和语义是十分必要的技巧。

学习最佳的方式对我来说是做。阅读大量充满了抽象概念的段落并吸收它们很难，只有编码，运行，调试后，才能有所收获。

静态类型系统特别需要及其形式化的推导(formal reasoning)。探索(hacking,我理解为探索)一个类型系统和在数学中证明一个定理感觉类似。这不是巧合。Haskell curry和William Alvin Howard展示了它们是硬币的两个方面：参见[curry-howard同构](https://en.wikipedia.org/wiki/Curry–Howard_correspondence)。

### 为什么要学习实现编程语言(实现编程语言的解释器/编译器)
虽然开发一个被广泛使用的编程语言不太可能。但是还是有很多理由让我们实现一门编程语言的。
1. 小语言随处可见，我们称之为DSL。例如，应用脚本语言，模板引擎，标记格式以及配置文件。几乎所有大型软件项目都需要它们中的一些。尽管使用已经存在的一个实现优先级要高于自己编写一个，但是一旦当没有一个已有的库满足你的需求的时候，你发现需要实现一个解析器或者其他工具时，就很有用了。即使，你使用的时已有的实现，但你总有可能最终要调试和维护它。
2. 编程语言是很好的实践，实现一个编程语言对于编程技巧来说是真实的测试。它的代码很复杂，并且性能很重要。你需要掌握递归，动态数组，树，图以及哈希表。尽管本书不想向你展示解释器可能会如同你想的那样难，但是实现它依旧很有挑战。
3. 程序员三大浪漫：操作系统，计算机图形学，编程语言。

### 本书怎么样

本书分为两部分，第一部分将会告诉你一些编程语言玩家的术语，向你介绍Lox--我们将要实现的语言。每一部分都实现了一个完整的解释器。每一章的结构是一样的：选取一个语言功能，教会你他背后的概念，以及带你穿过它的一个实现。

很多其他讲述编程语言的书或者编程语言的实现使用了类似[Lex](https://en.wikipedia.org/wiki/Lex_(software))和[Yacc](https://en.wikipedia.org/wiki/Yacc)这样的工具，叫做 __编译器编译器__，它们自动生成了某些高层级的描述。
>Yacc是一个工具，用语法文件(grammar file)作为参数，返回一个编译器源文件。所以说他是算是一个编译器，输出一个编译器，因此叫做compiler-compiler。还有一个比它要晚出来工具[Bison](https://en.wikipedia.org/wiki/GNU_bison)

这里我们不会使用这些工具，一切都是自己手写。本书会受到“真实世界”的一些约束，因此代码规范(code style)不会总是反射出来编写可维护产品软件的最佳实践。

大多数编程语言书籍其实都是编程语言实现书。他们很少讨论如果一个人可能碰巧要设计一门待实现的语言。一旦你要开始设计一门语言(不是实现一门)就需要注意更人性的一些东西了，比如，哪些功能易于学习，如何平衡创新和熟悉，什么语法更易读以及是针对谁的。

### 第一个解释器
第一个解释器jLox使用java编写。主要关注于解释器的概念。我们将编写最简化最干净的代码正确实现这门语言的语义。这将有助于我们理解基础概念并理解这个语言的行为到底是什么样的。
选择java的主要原因：
1. 他足够高级(high level)并且不想脚本语言那样将复杂性隐藏起来，你可以通过静态类型看到你正在处理的数据结构
2. 他是OO的语言，你已经习惯了将代码按照类和方法组织起来。面向对象很常见，而且大部分也实现了自举。
   编译器读取用一个语言编写的文件，翻译它们，然后输出用另外一个语言编写的文件。你可以用任何语言实现一个编译器，包括这个编译器自己将编译的语言，这个过程叫做自举(self-hosting)。一开始，你不能使用你的编译器自身编译自己。但是，如果你有用另外一个语言编写的可以编译你的语言的编译器，你使用它编译你的编译器一次。现在你可以用你自己编译器的已编译它将来的版本，然后你就可以丢弃那个用其他编译器编译的编译器，这叫做bootstrapping。(简单来说，用L1语言实现一个L2语言的编译器C1，然后用L2编写一个L2的编译器C2，用C1编译C2，得到一个L2编写的编译器C2的可执行版本，后面都用C2编译了)
3. 最后，Java流行广泛
这一部分结束后，就会有一个简单，可读的实现。虽然不快，但他是正确的。然而，我们只能通过构建在JVM自己的运行时工具之上实现这些功能。我们想知道java自己是怎么实现这些东西的。
### 第二个解释器
后面，将使用C再写一遍解释器。C是理解一个解释器实现真正工作方式的完美语言，所有的内容直到内存中的字节以及流经CPU的代码。使用C的一大原因是本书会向你展示C特别擅长的事情，但这意味着你需要很适应它。在我们的C实现的解释器clox中，我们专注于自己实现那些Java免费提供给我们的功能。我们将自己实现动态数组和哈希表，我们将自己决定对象在内存中如何表示的，并构建一个垃圾回收器回收它们。Java的实现专注于正确，C的实现专注于快速。C实现包括一个编译器，将Lox翻译成一个高效的字节码表示，然后执行字节码。
